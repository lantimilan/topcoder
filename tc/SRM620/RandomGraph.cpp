#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

// state (i, j, k) = probability that total we have i vertices, among which there are j pairs and k triples,
// and the rest i - 2*j - 3*k are singletons
//
// from (i, j, k), we process the (i+t)th vertex, W
// case 1: W is a singleton
// case 2: W connects to one of the s singletons, where s = i - 2*j - 3*k
// case 2.1: W connects to two of the s singletons, where s = i - 2*j - 3*k
// case 3: W connects to one of the j pairs
// other: W cannot connect to any of the k triples because this will give us a size-4 component

double state[55][55][55];

class RandomGraph {
public:
	double probability(int n, int pp) {
        double p = pp / 1000.0;

        /*
        if (p == 1.0) {
            if (n >= 4) return 1.0;
            else return 0.0;
        }
        */
        double g1[55], g2[55];
        g1[0] = g2[0] = 1.0;
        for (int i = 0; i < n; ++i) {
            g1[i+1] = g1[i] * p;
            g2[i+1] = g2[i] * (1-p);
        }

        memset(state, 0, sizeof state);
        state[0][0][0] = 1.0;
        for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= n; ++j)
        for (int k = 0; k <= n; ++k)
        //if (i >= j*2 + k*3) {
        {
            double st = state[i][j][k];
            // case 1: singleton, (i,j,k) -> (i+1, j, k), not connected to any of the i vertices
            state[i+1][j][k] += st * g2[i]; //pow(1-p, i);
            // case 2: connect to one of the s singleton, s choices, each is p * (1-p)^(i-1)
            // (i, j, k) -> (i+1, j+1, k)
            int s = i - 2*j - 3*k;
            if (s > 0) {
                if (i > 0)
                    state[i+1][j+1][k] += st * s * p * g2[i-1]; // * pow(1-p, i-1) * st;
            }
            // case 2.1: connect to two of the s singleton,
            // (i, j, k) -> (i+1, j, k+1)
            // (s choose 2) choices for the two singleton
            if (s > 1) {
                double mult = s * (s-1) / 2.0 * p * p * g2[i-2];
                state[i+1][j][k+1] += st * mult;
            }
            // case 3: connect to one of the j pairs to form a triple, j choices
            // now (i+1) could connect to both (u,v), (u not v), and (v not u)
            // (i, j, k) -> (i+1, j-1, k+1)
            if (j > 0) {
                double mult = 0.0;
                mult += j * p * p * g2[i-2]; // * pow(1-p, i-2);
                mult += j * p * g2[i-1]; //pow(1-p, i-1);
                mult += j * p * g2[i-1]; //pow(1-p, i-1);
                state[i+1][j-1][k+1] += st * mult;
            }
        }
        double ans = 0.0;
        for (int j = 0; j <= n; ++j)
        for (int k = 0; k <= n; ++k)
            //if (j*2 + k*3 <= n)
                ans += state[n][j][k];
        return 1.0 - ans;  // had a bug earlier, forgot to mult by st in some cases, then got negative number here
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, double p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	RandomGraph *obj;
	double answer;
	obj = new RandomGraph();
	clock_t startTime = clock();
	answer = obj->probability(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = fabs(p2 - answer) <= 1e-9 * max(1.0, fabs(p2));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	int p0;
	int p1;
	double p2;

	{
	// ----- test 0 -----
	p0 = 7;
	p1 = 0;
	p2 = 0.0;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	p0 = 3;
	p1 = 620;
	p2 = 0.0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	p0 = 4;
	p1 = 500;
	p2 = 0.59375;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	p0 = 8;
	p1 = 100;
	p2 = 0.33566851611343496;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	p0 = 15;
	p1 = 50;
	p2 = 0.5686761670525845;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 5 -----
	p0 = 50;
	p1 = 10;
	p2 = 0.7494276522159893;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 6 -----
	p0 = 50;
	p1 = 1000;
	p2 = 1.0;
	all_right = KawigiEdit_RunTest(6, p0, p1, true, p2) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
